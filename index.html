<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Height Prediction Calculator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 24px; background: #f4f8fc; }
    .container { max-width: 960px; margin: auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.08); }
    h1 { text-align: center; color: #222; margin-bottom: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-start; }
    .col { flex: 1 1 220px; min-width: 180px; }
    label { display:block; font-weight:600; margin-top:8px; }
    input, select, button { width:100%; padding:8px 10px; margin-top:6px; border-radius:8px; border:1px solid #ccc; box-sizing:border-box; }
    button { background:#0078D7; color:#fff; font-weight:600; cursor:pointer; }
    button.secondary { background:#555; }
    .controls { margin-top:12px; display:flex; gap:8px; }
    .result { margin-top:18px; padding:14px; background:#e8f4ff; border-radius:10px; border-left:5px solid #0078D7; white-space:pre-wrap; }
    .small { font-size:0.9rem; color:#444; }
    canvas { margin-top:18px; background:#fff; border-radius:8px; padding:8px; }
    .msg { margin-top:8px; font-weight:600; }
    .success { color:green; }
    .error { color:crimson; }
  </style>

  <!-- Define toggleParents early so inline onchange won't fail -->
  <script>
    // global function referenced by inline onchange on the select
    window.toggleParents = function() {
      try {
        var modeEl = document.getElementById("mode");
        var parentsSection = document.getElementById("parentsSection");
        if (!modeEl || !parentsSection) return;
        var mode = modeEl.value;
        if (mode === "child_parents") {
          parentsSection.style.display = "flex";
        } else {
          parentsSection.style.display = "none";
          var f = document.getElementById("father");
          var m = document.getElementById("mother");
          if (f) f.value = "";
          if (m) m.value = "";
        }
      } catch (e) {
        // fail silently but log for debug
        console.warn("toggleParents error:", e);
      }
    };
  </script>
</head>
<body>
  <div class="container">
    <h1>Height Prediction Calculator</h1>

    <!-- Prediction Mode (at the top) -->
    <div class="row">
      <div class="col">
        <label for="mode">Prediction Mode</label>
        <!-- inline onchange kept for robustness -->
        <select id="mode" aria-label="Prediction mode" onchange="toggleParents()">
          <option value="child">Child only (Percentile-based)</option>
          <option value="child_parents">Child + Parents (Percentile + MPH)</option>
        </select>
      </div>
    </div>

    <!-- Name -->
    <div class="row" style="margin-top:6px;">
      <div class="col">
        <label for="name">Name</label>
        <input id="name" type="text" placeholder="Child's name (optional)">
      </div>
    </div>

    <!-- Location -->
    <div class="row">
      <div class="col">
        <label for="country">Country</label>
        <input id="country" type="text" placeholder="Country">
      </div>
      <div class="col">
        <label for="state">State</label>
        <input id="state" type="text" placeholder="State">
      </div>
      <div class="col">
        <label for="district">District</label>
        <input id="district" type="text" placeholder="District">
      </div>
    </div>

    <!-- Gender, Age, Height -->
    <div class="row">
      <div class="col">
        <label for="gender">Gender</label>
        <select id="gender">
          <option value="Male">Male</option>
          <option value="Female">Female</option>
        </select>
      </div>
      <div class="col">
        <label for="age">Current Age (years, decimals allowed)</label>
        <input id="age" type="number" step="0.01" min="0" max="20" placeholder="e.g. 7.5">
      </div>
      <div class="col">
        <label for="height">Current Height (cm)</label>
        <input id="height" type="number" step="0.1" min="0" placeholder="e.g. 125.4">
      </div>
    </div>

    <!-- Parents Heights (hidden by default) -->
    <div class="row" id="parentsSection" style="display:none; margin-top:8px; align-items:flex-end;">
      <div class="col">
        <label for="father">Father's Height (cm)</label>
        <input id="father" type="number" step="0.1" min="0" placeholder="e.g. 172.0">
      </div>
      <div class="col">
        <label for="mother">Mother's Height (cm)</label>
        <input id="mother" type="number" step="0.1" min="0" placeholder="e.g. 160.0">
      </div>
      <div class="col" style="min-width:160px;">
        <label for="adultAge">Project adult height to age</label>
        <select id="adultAge">
          <option value="18">18 years</option>
          <option value="20">20 years</option>
        </select>
      </div>
    </div>

    <!-- Buttons -->
    <div class="row">
      <div class="col">
        <div class="controls">
          <button id="predictBtn">Predict</button>
          <button id="printBtn" class="secondary">üñ® Print</button>
        </div>
      </div>
    </div>

    <!-- Results -->
    <div id="results" class="result" style="display:none;"></div>
    <div id="logMsg" class="msg" style="display:none;"></div>

    <!-- Chart -->
    <canvas id="growthChart" width="920" height="420"></canvas>
    <div class="small">Red = current, Green = percentile-based predicted, Purple = MPH-based predicted (if parents provided), Blue dashed = trajectory.</div>
  </div>

<script>
/* ------------------
  Configuration ‚Äî set your Apps Script URL here
---------------------*/
const SHEET_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbz73tJdxWhXBMxIjsWcN6WNWLnFkK8OPYpjNIrb0oV5JNj4efTyfDRuh4LMWv7A1BtwaQ/exec";

/* DOM refs */
const modeEl = document.getElementById("mode");
const parentsSection = document.getElementById("parentsSection");
const predictBtn = document.getElementById("predictBtn");
const printBtn = document.getElementById("printBtn");
const resultsEl = document.getElementById("results");
const logMsgEl = document.getElementById("logMsg");
let chart = null;

/* wire up events after DOM ready */
document.addEventListener("DOMContentLoaded", () => {
  // add listener too (redundant with inline onchange but robust)
  modeEl.addEventListener("change", toggleParents);
  predictBtn.addEventListener("click", onPredictClicked);
  printBtn.addEventListener("click", () => window.print());
  // initialize parents visibility (call once)
  toggleParents();
  // draw skeleton chart
  initSkeletonChart();
});

/* Utility: fetch JSON file */
async function loadJsonFile(filename) {
  const res = await fetch(filename, { cache: "no-store" });
  if (!res.ok) throw new Error("Could not load " + filename + " (status " + res.status + ")");
  return res.json();
}

/* Predict button handler */
async function onPredictClicked() {
  predictBtn.disabled = true;
  logMsgEl.style.display = "none";
  try {
    await predictHeight();
  } catch (err) {
    resultsEl.style.display = "block";
    resultsEl.innerText = "‚ùå Error: " + (err.message || err);
    console.error(err);
  } finally {
    predictBtn.disabled = false;
  }
}

/* Main prediction */
async function predictHeight() {
  const mode = document.getElementById("mode").value;
  const name = document.getElementById("name").value.trim();
  const country = document.getElementById("country").value.trim();
  const state = document.getElementById("state").value.trim();
  const district = document.getElementById("district").value.trim();
  const gender = document.getElementById("gender").value;
  const age = parseFloat(document.getElementById("age").value);
  const currentHeight = parseFloat(document.getElementById("height").value);
  const father = parseFloat(document.getElementById("father").value);
  const mother = parseFloat(document.getElementById("mother").value);
  const adultAge = parseInt(document.getElementById("adultAge").value, 10);

  if (isNaN(age) || isNaN(currentHeight)) {
    resultsEl.style.display = "block";
    resultsEl.innerText = "‚ùå Please enter valid age and current height.";
    return;
  }

  // load main growth dataset
  const mainFile = gender === "Male" ? "Male.json" : "Female.json";
  const mainJson = await loadJsonFile(mainFile);
  const mainData = Array.isArray(mainJson.data) ? mainJson.data : mainJson; // support either format

  // ensure mainData sorted by Age ascending
  mainData.sort((a,b)=>Number(a.Age)-Number(b.Age));

  // clamp age to data range
  const minAge = Number(mainData[0].Age);
  const maxAge = Number(mainData[mainData.length-1].Age);
  const clampedAge = Math.max(minAge, Math.min(maxAge, age));

  // find lower and upper rows for interpolation
  let lower = mainData[0];
  for (let i=0;i<mainData.length;i++){
    if (Number(mainData[i].Age) <= clampedAge) lower = mainData[i]; else break;
  }
  let upper = mainData.find(item => Number(item.Age) >= clampedAge) || mainData[mainData.length - 1];
  // if both are same (at edges), interpolation factor = 0
  const denom = (Number(upper.Age) - Number(lower.Age)) || 1;
  const factor = (clampedAge - Number(lower.Age)) / denom;

  // percentiles keys (exclude Age)
  const percentileKeys = Object.keys(lower).filter(k => k !== "Age");

  // interpolate percentiles at current age
  const interpolated = {};
  percentileKeys.forEach(k => {
    const lowV = Number(lower[k]);
    const upV = Number(upper[k]);
    interpolated[k] = Number.isFinite(lowV) && Number.isFinite(upV) ? (lowV + factor * (upV - lowV)) : NaN;
  });

  // nearest percentile to current height
  let nearest = percentileKeys.length ? percentileKeys[0] : null;
  if (nearest) {
    let minDiff = Math.abs((interpolated[nearest]||0) - currentHeight);
    percentileKeys.forEach(k => {
      const val = interpolated[k];
      if (!Number.isFinite(val)) return;
      const diff = Math.abs(val - currentHeight);
      if (diff < minDiff) { minDiff = diff; nearest = k; }
    });
  }

  // get adult row (exact adultAge or last available)
  const adultRow = mainData.find(r => Number(r.Age) === Number(adultAge)) || mainData[mainData.length - 1];

  // predicted by percentile method (fallback to median if necessary)
  let predicted_percentileBased = null;
  if (nearest && adultRow && adultRow.hasOwnProperty(nearest)) {
    predicted_percentileBased = Number(adultRow[nearest]);
  } else if (adultRow && adultRow.hasOwnProperty('P50')) {
    predicted_percentileBased = Number(adultRow['P50']);
  } else {
    predicted_percentileBased = NaN;
  }

  // MPH method (only if mode child_parents and both parents provided)
  let mph = null, mphPercentile = null, predicted_mph = null;
  if (mode === "child_parents" && !isNaN(father) && !isNaN(mother)) {
    mph = (father + mother) / 2;
    const mphFile = gender === "Male" ? "male_mph.json" : "female_mph.json";
    try {
      const mphJson = await loadJsonFile(mphFile);
      let mphData = Array.isArray(mphJson.data) ? mphJson.data : (Array.isArray(mphJson) ? mphJson : (mphJson.data ? mphJson.data : []));

      // try multiple possible field names for midparental value
      const mpFieldCandidates = ['Midparental_m','Midparental','midparental_m','midparental','midparental_cm','Midparental_cm'];

      if (mphData.length) {
        // find the row with the closest midparental value
        let closest = mphData[0];
        let mpVal0 = getFirstFieldValue(mphData[0], mpFieldCandidates);
        let mdiff = Math.abs(mpVal0 - mph);
        for (let i=0;i<mphData.length;i++){
          const row = mphData[i];
          const mpVal = getFirstFieldValue(row, mpFieldCandidates);
          if (!Number.isFinite(mpVal)) continue;
          const diff = Math.abs(mpVal - mph);
          if (diff < mdiff) { mdiff = diff; closest = row; }
        }
        // try to read Percentile or percentile field
        mphPercentile = (closest.Percentile || closest.percentile || closest.p || closest.P) || null;
        // ensure mphPercentile matches adultRow keys (like 'P50')
        if (mphPercentile && !adultRow.hasOwnProperty(mphPercentile)) {
          // try to convert numeric percentile like 50 -> 'P50'
          const asNum = Number(mphPercentile);
          if (Number.isFinite(asNum)) mphPercentile = 'P' + asNum;
        }
        if (mphPercentile && adultRow && adultRow.hasOwnProperty(mphPercentile)) {
          predicted_mph = Number(adultRow[mphPercentile]);
        }
      }
    } catch(e) {
      console.warn('MPH file missing or invalid, skipping MPH method', e);
    }
  }

  // Display simplified results (no ¬± ranges)
  let html = "";
  html += `‚úÖ Gender: <b>${gender}</b>\n`;
  html += `‚úÖ Age: <b>${age} years</b>\n`;
  html += `üåç Country: <b>${country || "-"}</b>\n`;
  html += `üèûÔ∏è State: <b>${state || "-"}</b>, District: <b>${district || "-"}</b>\n\n`;
  html += `üìä Predicted Adult Height (Percentile-based): <b>${Number.isFinite(predicted_percentileBased)?predicted_percentileBased+' cm':'N/A'}</b>\n`;
  if (predicted_mph !== null && Number.isFinite(predicted_mph)) {
    html += `üìä Predicted Adult Height (MPH-based): <b>${predicted_mph} cm</b>\n`;
  }
  resultsEl.style.display = "block";
  resultsEl.innerHTML = html;

  // Chart
  drawChart(mainData, age, currentHeight, adultAge, predicted_percentileBased, predicted_mph, nearest, mphPercentile);

  // Logging payload (no lower/upper)
  const payload = {
    timestamp: new Date().toISOString(),
    name: name || "",
    country: country || "",
    state: state || "",
    district: district || "",
    gender,
    age,
    currentHeight,
    percentile_current: nearest || '',
    predicted_percentileBased: Number.isFinite(predicted_percentileBased)?predicted_percentileBased:'',
    father: !isNaN(father) ? father : "",
    mother: !isNaN(mother) ? mother : "",
    mph: mph !== null ? Number(mph.toFixed(2)) : "",
    mph_percentile: mphPercentile || "",
    predicted_mph: (predicted_mph !== null && Number.isFinite(predicted_mph)) ? predicted_mph : ""
  };

  try {
    await logToSheet(payload);
    showLogMessage("üì§ Data saved to Google Sheets ‚úÖ", true);
  } catch (err) {
    console.error("Logging failed:", err);
    showLogMessage("‚ö†Ô∏è Logging to Google Sheets failed.", false);
  }
}

/* Chart drawing */
function drawChart(mainData, age, currentHeight, adultAge, predicted_percentileBased, predicted_mph, nearestPercentile, mphPercentile) {
  const chartPercentiles = ["P3","P10","P25","P50","P75","P90","P97"];
  const datasets = chartPercentiles.map(p => ({
    label: p,
    data: mainData.map(d => ({ x: Number(d.Age), y: Number(d[p]) })),
    borderColor: getColor(p),
    borderWidth: 2,
    fill: false,
    tension: 0.3,
    pointRadius: 0
  }));

  const trajectory = mainData.filter(d => Number(d.Age) >= age && Number(d.Age) <= adultAge).map(d => ({ x: Number(d.Age), y: Number(d[nearestPercentile] || d['P50']) }));
  datasets.push({
    label: "Trajectory",
    data: trajectory,
    borderColor: "blue",
    borderWidth: 3,
    borderDash: [6,4],
    fill: false,
    tension: 0,
    pointRadius: 0
  });

  datasets.push({
    label: "Current",
    data: [{ x: age, y: currentHeight }],
    backgroundColor: "red",
    borderColor: "red",
    pointRadius: 6,
    type: "scatter"
  });

  datasets.push({
    label: "Predicted (Percentile)",
    data: [{ x: adultAge, y: predicted_percentileBased }],
    backgroundColor: "green",
    borderColor: "green",
    pointRadius: 6,
    type: "scatter"
  });

  if (predicted_mph !== null && predicted_mph !== undefined && predicted_mph !== "") {
    datasets.push({
      label: "Predicted (MPH)",
      data: [{ x: adultAge, y: predicted_mph }],
      backgroundColor: "purple",
      borderColor: "purple",
      pointRadius: 6,
      type: "scatter"
    });

    if (mphPercentile && mainData[0] && mainData[0].hasOwnProperty(mphPercentile)) {
      const mphTrajectory = mainData.filter(d => Number(d.Age) >= age && Number(d.Age) <= adultAge).map(d => ({ x: Number(d.Age), y: Number(d[mphPercentile]) }));
      datasets.push({
        label: "MPH Trajectory",
        data: mphTrajectory,
        borderColor: "purple",
        borderWidth: 2,
        borderDash: [3,3],
        fill: false,
        tension: 0,
        pointRadius: 0
      });
    }
  }

  if (chart) chart.destroy();
  const ctx = document.getElementById("growthChart").getContext("2d");
  chart = new Chart(ctx, {
    type: "line",
    data: { datasets },
    options: {
      responsive: true,
      plugins: {
        legend: { position: "bottom" },
        tooltip: {
          callbacks: {
            label: c => `${c.dataset.label}: ${c.parsed.y} cm at age ${c.parsed.x}`
          }
        }
      },
      scales: {
        x: { type: "linear", title: { display: true, text: "Age (years)" } },
        y: { title: { display: true, text: "Height (cm)" } }
      }
    }
  });
}

function getColor(p) {
  const map = { "P3":"#ff6384","P10":"#ff9f40","P25":"#ffcd56","P50":"#4bc0c0","P75":"#36a2eb","P90":"#9966ff","P97":"#c9cbcf" };
  return map[p] || "#666";
}

/* utility: read first available numeric field from an object */
function getFirstFieldValue(obj, candidates) {
  for (const k of candidates) {
    if (obj && obj.hasOwnProperty(k)) {
      const v = Number(obj[k]);
      if (Number.isFinite(v)) return v;
    }
  }
  // try any numeric-like property
  for (const k of Object.keys(obj||{})) {
    const v = Number(obj[k]);
    if (Number.isFinite(v)) return v;
  }
  return NaN;
}

/* Logging to Google Sheets Apps Script */
async function logToSheet(payload) {
  // If no URL configured, skip silently
  if (!https://script.google.com/macros/s/AKfycbzA6TuYpP2IkBFpx6udY5mo1hgxIqK0T3f0FwtGaV5BStqkToffKKmgkbueT-l9_Jx5WQ/exec || https://script.google.com/macros/s/AKfycbzA6TuYpP2IkBFpx6udY5mo1hgxIqK0T3f0FwtGaV5BStqkToffKKmgkbueT-l9_Jx5WQ/exec.trim() === "") return Promise.resolve('skipped');
  const res = await fetch(https://script.google.com/macros/s/AKfycbzA6TuYpP2IkBFpx6udY5mo1hgxIqK0T3f0FwtGaV5BStqkToffKKmgkbueT-l9_Jx5WQ/exec, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  if (!res.ok) {
    const txt = await res.text().catch(()=>res.statusText);
    throw new Error("Sheet logging failed: " + txt);
  }
  return res.text().catch(()=>"ok");
}

/* show result of logging */
function showLogMessage(msg, ok=true) {
  logMsgEl.style.display = "block";
  logMsgEl.innerText = msg;
  logMsgEl.className = ok ? "msg success" : "msg error";
  setTimeout(()=> { logMsgEl.style.display = "none"; }, 6000);
}

/* draw skeleton chart */
async function initSkeletonChart() {
  try {
    const json = await loadJsonFile("Male.json");
    const data = Array.isArray(json.data) ? json.data : json;
    drawChart(data, 0, 0, 18, 0, null, "P50", null);
  } catch (e) { console.warn('Could not draw skeleton chart (Male.json missing)', e); }
}
</script>
</body>
</html>


